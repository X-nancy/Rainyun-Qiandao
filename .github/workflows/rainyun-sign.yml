name: Rainyun 自动签到

on:
  schedule:
    - cron: '0 4 * * *'  # UTC+8 12点执行
    - cron: '0 0 1 * *'  # 每月1日0点执行保活机制
  workflow_dispatch:
    # 允许手动触发，并支持传递重试参数
    inputs:
      is_retry:
        description: '是否为重试执行'
        required: false
        default: 'false'
        type: boolean
      retry_count:
        description: '重试次数'
        required: false
        default: '0'
        type: number

jobs:
  sign-in:
    runs-on: ubuntu-latest
    # 添加重试策略，最多3次重试（根据需要调整）
    # 但我们会使用自定义重试逻辑以满足时间限制要求
    steps:
      - uses: actions/checkout@v3
      
      - name: 设置Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: 缓存Python依赖
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-
      
      - name: 安装依赖
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # 移除Chrome浏览器缓存，因为缓存系统目录可能导致权限问题
      # 使用webdriver-manager自动管理ChromeDriver，无需缓存
      
      - name: 安装Chrome和ChromeDriver
        run: |
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable curl unzip
          # 使用webdriver-manager自动管理ChromeDriver版本
          pip install webdriver-manager chromedriver-binary-auto
      
      - name: 确保temp目录存在
        run: mkdir -p temp
      
      - name: 执行签到脚本
        id: sign_in
        run: python rainyun.py
        env:
          # 请在GitHub仓库的Settings > Secrets and variables > Actions中设置这些密钥
          RAINYUN_USER: ${{ secrets.RAINYUN_USER }}
          RAINYUN_PASS: ${{ secrets.RAINYUN_PASS }}
          # 设置无头模式环境变量
          HEADLESS: "true"
          # 启用调试日志
          DEBUG: "false"
          # 确保使用系统路径中的ChromeDriver
          CHROMEDRIVER_PATH: "chromedriver"
      
      - name: 清理临时文件
        run: rm -rf temp
        if: always()  # 即使前面步骤失败也执行清理
      
      # 失败重试机制
      - name: 检查执行状态并安排重试
        if: failure() && github.event_name != 'schedule' || (failure() && github.event_name == 'schedule' && github.event.schedule != '0 0 1 * *')
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 获取重试相关参数
            const isRetry = ${{ github.event.inputs.is_retry || 'false' }};
            let retryCount = parseInt(${{ github.event.inputs.retry_count || '0' }});
            
            // 获取当前时间并转换为UTC+8时区
            const now = new Date();
            // 转换为UTC+8时区
            const utc8Time = new Date(now.getTime() + 8 * 60 * 60 * 1000);
            const currentHour = utc8Time.getHours();
            
            console.log(`当前UTC+8时间: ${utc8Time.toISOString()}`);
            console.log(`当前UTC+8小时: ${currentHour}`);
            console.log(`是否重试: ${isRetry}, 当前重试次数: ${retryCount}`);
            
            // 检查是否在UTC+8晚上10点前
            if (currentHour < 22) {
              // 计划1小时后重试
              retryCount++;
              console.log(`安排1小时后进行第${retryCount}次重试`);
              
              // 使用GitHub API触发工作流重试
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'rainyun-sign.yml',
                  ref: context.ref,
                  inputs: {
                    is_retry: 'true',
                    retry_count: retryCount.toString()
                  }
                });
                
                console.log(`重试已安排，将在1小时后执行第${retryCount}次尝试`);
              } catch (error) {
                console.error('安排重试失败:', error.message);
                console.log('将在1小时后重试...');
                
                // 如果API调用失败，等待1小时后再次执行
                await new Promise(resolve => setTimeout(resolve, 60 * 60 * 1000));
                
                try {
                  await github.rest.actions.createWorkflowDispatch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: 'rainyun-sign.yml',
                    ref: context.ref,
                    inputs: {
                      is_retry: 'true',
                      retry_count: retryCount.toString()
                    }
                  });
                  console.log(`等待后重试已安排`);
                } catch (retryError) {
                  console.error('等待后重试也失败:', retryError.message);
                }
              }
            } else {
              console.log('当前时间已过UTC+8晚上10点，停止重试');
              console.error('工作流执行失败，且已超过重试时间限制');
            }

      # 保活机制 - 防止GitHub Actions工作流因30天不活跃而被禁用
      - name: Keepalive Workflow
        if: github.event.schedule == '0 0 1 * *'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 自动更新工作流文件以保持活跃状态
            try {
              const workflow = await github.rest.actions.getWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'rainyun-sign.yml'
              });
              
              // 触发工作流自己运行一次作为保活
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'rainyun-sign.yml',
                ref: context.ref
              });
              
              console.log('工作流保活成功！');
            } catch (error) {
              console.error('工作流保活失败:', error.message);
            }